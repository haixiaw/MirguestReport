\section{Design and Implementation of the Transfer System}

\subsection{Transfer Request Service}

The transfer request service support a basic management which includes:
\begin{itemize}
    \item create a new transfer request with dataset name,
          source SE, destination SE and protocol.
    \item show the status of the specific transfer request.
    \item kill or re-transfer one transfer process.
\end{itemize}
%
\subsection{Transfer Agent}
%
The Transfer Agent implements a non-blocking scheduler.
It uses python's standard library {\tt subprocess} to 
create the real transfer worker in a new process
and uses async I/O to communicate with this process.
The output and status of the sub process will be used 
to indicate whether the transfer is OK or not.
%
The workflow of the transfer agent is shown in Figure \ref{fig:agent}
and described as follows.
\begin{figure}[htbp]
    %\centering
    \input{sub_transagent.tex}
    \caption{Workflow of transfer agent} \label{fig:agent}
\end{figure}

\begin{enumerate}
\item The scheduler checks the existing worker.
It can be divided into several steps:
\begin{enumerate}
    \item Check the status in database.
          If user kills a transfer worker, the state in
          database will become ``kill''.
          So the scheduler will
          send a signal to terminate the
          transfer process.
    \item Check the process is terminated or not.
          If it is terminated, we need to do some other things.
    \item Remove the worker from the queue.
    \item Handle the exit code to check the transfer is OK or not.
    \item Update the status in the database 
          and commit the entry in accounting system.
\end{enumerate}
\item The scheduler will add new worker if possible.
If the system is idle and there are new requests,
scheduler will create the new worker.
Here, we will initialize the transfer worker and use the accounting
system to create a new entry with some informations.
\end{enumerate}
% Transfer Factory
For flexibility, we use a {\tt TransferFactory} to create transfer workers
with different protocols. 
We define an interface {\tt ITransferWorker},
which will be used by the transfer agent. The derived class should
implement the interface and construct the command line which will 
be called when the worker begins to run.
The derived class can also define how to handle the output of the 
program.
This design allows us to build high-level transfer system.
We reuse the low-level transfer programs and abstract these
progress in the {\tt ITransferWorker}.

\subsection{Transfer Database}

In the transfer system, transfer request service and transfer agent
share the data using transfer database. In the database, we maintain
two tables.
One is for the transfer status of dataset 
and another is for the transfer status of files in dataset. 
The schemas of these tables are defined 
in {\tt BESDIRAC/TransferSystem/DB/TransferDB.sql} in the {\tt BESDIRAC}
project\cite{bib:besdirac}.
